public class IpMacUtils {
    private static final Log LOG = LogFactory.getLog(IpMacUtils.class);
    public static final String IPV4_ADDRESS_PATTERN = "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\x2e){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    public static final String IPV6_ADDRESS_PATTERN = "(([a-fA-F0-9]{1,4}):){7}([a-fA-F0-9]{1,4})";
    public static final Pattern MAC3 = Pattern.compile("([a-fA-F0-9]{1,4}-){2}[a-fA-F0-9]{1,4}");
    public static final Pattern MAC3_WITH_MASK = Pattern.compile("([a-fA-F0-9]{1,4}-){2}[a-fA-F0-9]{1,4}/([a-fA-F0-9]{1,4}-){2}[a-fA-F0-9]{1,4}");
    public static final Pattern MAC6 = Pattern.compile("([a-fA-F0-9]{1,2}-){5}[a-fA-F0-9]{1,2}");
    public static final Pattern MAC6COLON = Pattern.compile("(([a-fA-F0-9]{1,2}:){5}[a-fA-F0-9]{1,2}){1}");
    public static final Pattern MAC6_WITH_MASK = Pattern.compile("([a-fA-F0-9]{1,2}-){5}[a-fA-F0-9]{1,2}/([a-fA-F0-9]{1,2}-){5}[a-fA-F0-9]{1,2}");
    static Map<String, String> dnsHashmap = new HashMap();

    public IpMacUtils() {
    }

    @ExternalInterface
    public static long convertIpV4ToLong(String hostIp) {
        if(null == hostIp) {
            LOG.error("Host IP can not be null");
            throw new NullPointerException("Host IP can not be null");
        } else {
            String[] parts = hostIp.trim().split("\\x2e");
            if(parts.length != 4) {
                LOG.error("Invalid ip address: " + hostIp);
                return 0L;
            } else {
                long ip = 0L;
                String[] arr$ = parts;
                int len$ = parts.length;

                for(int i$ = 0; i$ < len$; ++i$) {
                    String part = arr$[i$];

                    try {
                        int nfe = Integer.parseInt(part.trim());
                        if(nfe < 0 || nfe > 255) {
                            LOG.error("Invalid ip address: " + hostIp);
                            return 0L;
                        }

                        ip = ip << 8 | (long)nfe;
                    } catch (NumberFormatException var9) {
                        LOG.error("Invalid ip address: " + hostIp, var9);
                        return 0L;
                    }
                }

                return ip;
            }
        }
    }

    @ExternalInterface
    public static String convertLongToIpV4(long longIp) {
        return (longIp >> 24 & 255L) + "." + (longIp >> 16 & 255L) + "." + (longIp >> 8 & 255L) + "." + (longIp & 255L);
    }

    @ExternalInterface
    public static double convertIpV6ToDouble(String strIpv6) {
        try {
            String ue = ((Inet6Address)Inet6Address.getByName(strIpv6)).getHostAddress();
            ArrayList ipSections = new ArrayList();
            String[] fullIpv6 = StringUtils.split(ue, ":");
            int result = fullIpv6.length;

            for(int i$ = 0; i$ < result; ++i$) {
                String i = fullIpv6[i$];
                ipSections.add(i.length() < 4?StringUtils.repeat("0", 4 - i.length()) + i:i);
            }

            String var9 = StringUtils.join(ipSections.iterator(), "");
            double var10 = 0.0D;

            for(int var11 = 0; var11 < var9.length(); ++var11) {
                String s = StringUtils.substring(var9, var11, var11 + 1);
                if(Integer.valueOf(s, 16).intValue() != 0) {
                    var10 += Math.pow(16.0D, (double)(var9.length() - 1 - var11)) * (double)Integer.valueOf(s, 16).intValue();
                }
            }

            return var10;
        } catch (UnknownHostException var8) {
            throw new NumberFormatException(strIpv6 + " is not a IPv6 address.");
        }
    }

    public static long convertMacToLong(String mac) {
        if(!isLegalMac(mac)) {
            LOG.error("invalid mac address :" + mac);
            return -1L;
        } else {
            String macAddr = StringUtils.remove(mac, "-");
            macAddr = StringUtils.remove(macAddr, ":");
            long longMac = 0L;

            for(int i = 0; i < macAddr.length(); ++i) {
                if(i != 0) {
                    longMac <<= 4;
                }

                if(macAddr.charAt(i) >= 48 && macAddr.charAt(i) <= 57) {
                    longMac += (long)(macAddr.charAt(i) - 48);
                } else if(macAddr.charAt(i) >= 97 && macAddr.charAt(i) <= 102) {
                    longMac += (long)(macAddr.charAt(i) - 97 + 10);
                } else if(macAddr.charAt(i) >= 65 && macAddr.charAt(i) <= 70) {
                    longMac += (long)(macAddr.charAt(i) - 65 + 10);
                }
            }

            return longMac;
        }
    }

    public static String convertLongToMac(long longMac) {
        char[] strs = new char[12];

        for(int sb = 11; sb >= 0; --sb) {
            char i = (char)((int)(longMac & 15L));
            if(i >= 10) {
                i = (char)(i - 10 + 97);
            } else {
                i = (char)(i + 48);
            }

            strs[sb] = i;
            if(sb > 0) {
                longMac >>= 4;
            }
        }

        StringBuilder var5 = new StringBuilder();

        for(int var6 = 0; var6 < strs.length; ++var6) {
            var5.append(strs[var6]);
            if(var6 != strs.length - 1 && (var6 + 1) % 2 == 0) {
                var5.append("-");
            }
        }

        return var5.toString();
    }

    @ExternalInterface
    public static boolean isLegalIpV4(String ip) {
        if(StringUtils.isBlank(ip)) {
            return false;
        } else {
            Pattern p = Pattern.compile("(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\x2e){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])");
            return p.matcher(ip.trim()).matches();
        }
    }

    @ExternalInterface
    public static boolean isLegalIpV4WithMask(String ipMask, boolean isStandardMask) {
        if(StringUtils.isBlank(ipMask)) {
            return false;
        } else if(!ipMask.startsWith("/") && !ipMask.endsWith("/") && StringUtils.countMatches(ipMask, "/") == 1) {
            String[] parts = StringUtils.split(ipMask.trim(), "/");
            String ip = parts[0];
            String mask = parts[1];
            boolean legelMask = false;
            if(!isLegalIpV4(mask) && !isLegalMask(mask)) {
                try {
                    if(mask.length() > 1 && mask.startsWith("0")) {
                        return false;
                    }

                    int e = Integer.valueOf(mask).intValue();
                    if(e < 0 || e > 32) {
                        return false;
                    }

                    legelMask = true;
                } catch (Exception var7) {
                    return false;
                }
            } else {
                legelMask = isStandardMask?isLegalMask(mask):isLegalIpV4(mask);
            }

            return isLegalIpV4(ip) && legelMask;
        } else {
            return false;
        }
    }

    @ExternalInterface
    public static boolean isLegalIpV4WithMask(String ipMask) {
        return isLegalIpV4WithMask(ipMask, true);
    }

    @ExternalInterface
    public static boolean isLegalMac(String mac) {
        return StringUtils.isBlank(mac)?false:MAC6.matcher(mac.trim()).matches();
    }

    @ExternalInterface
    public static boolean isLegalMacWithMask(String mac) {
        return StringUtils.isBlank(mac)?false:MAC6_WITH_MASK.matcher(mac.trim()).matches();
    }

    @ExternalInterface
    public static boolean isLegalMac3(String mac) {
        return StringUtils.isBlank(mac)?false:MAC3.matcher(mac.trim()).matches();
    }

    @ExternalInterface
    public static boolean isLegalMac3WithMask(String mac) {
        return StringUtils.isBlank(mac)?false:MAC3_WITH_MASK.matcher(mac.trim()).matches();
    }

    public static String formatMac(String mac) {
        if(StringUtils.isBlank(mac)) {
            return mac;
        } else {
            mac = StringUtils.replace(mac, "-", ":");
            String[] macs = StringUtils.split(mac, ':');
            ArrayList macList = new ArrayList();
            String[] result = macs;
            int num = macs.length;

            String tmp;
            for(int i$ = 0; i$ < num; ++i$) {
                tmp = result[i$];
                int size = tmp.length();
                if(size > 2) {
                    for(int i = 0; i < size; i += 2) {
                        if(i + 2 <= size) {
                            macList.add(tmp.substring(i, i + 2));
                        } else {
                            macList.add(tmp.substring(size - 1));
                        }
                    }
                } else {
                    macList.add(tmp);
                }
            }

            String var9 = "";
            num = 0;
            Iterator var10 = macList.iterator();

            while(var10.hasNext()) {
                tmp = (String)var10.next();
                var9 = var9 + tmp;
                ++num;
                if(num < macList.size()) {
                    var9 = var9 + ":";
                }
            }

            return var9;
        }
    }

    public static String normalizeMac(String mac) {
        if(!StringUtils.isBlank(mac) && MAC6COLON.matcher(mac.trim()).matches()) {
            String[] macs = StringUtils.split(mac.trim(), ':');
            ArrayList macList = new ArrayList();
            String[] result = macs;
            int len$ = macs.length;

            for(int i$ = 0; i$ < len$; ++i$) {
                String newMac = result[i$];
                String macStr = newMac.trim();
                int size = macStr.length();
                if(size == 1) {
                    macStr = "0" + newMac.trim();
                }

                macList.add(macStr);
            }

            String var9 = StringUtils.join(macList, ":");
            return var9;
        } else {
            LOG.error("Invalid MAC address: " + mac);
            throw new NumberFormatException(mac + " is a invalid MAC address.");
        }
    }

    @ExternalInterface
    public static boolean isLegalMask(String mask) {
        if(StringUtils.isBlank(mask)) {
            return false;
        } else {
            String[] parts = mask.trim().split("\\x2e");
            if(mask.endsWith(".")) {
                return false;
            } else if(parts.length != 4) {
                return false;
            } else {
                StringBuffer maskBinary = new StringBuffer();
                String[] num0 = parts;
                int i = parts.length;

                for(int i$ = 0; i$ < i; ++i$) {
                    String part = num0[i$];
                    if(part.length() > 1 && part.startsWith("0")) {
                        return false;
                    }

                    try {
                        int nfe = Integer.parseInt(part.trim());
                        if(nfe < 0 || nfe > 255) {
                            return false;
                        }

                        String s = Integer.toBinaryString(nfe);

                        for(int i1 = 0; i1 < 8 - s.length(); ++i1) {
                            maskBinary.append("0");
                        }

                        maskBinary.append(s);
                    } catch (NumberFormatException var10) {
                        return false;
                    }
                }

                int var11 = 0;

                for(i = 0; i < maskBinary.length(); ++i) {
                    if(maskBinary.charAt(i) == 49) {
                        if(var11 >= 1) {
                            return false;
                        }
                    } else {
                        ++var11;
                    }
                }

                return true;
            }
        }
    }

    @ExternalInterface
    public static boolean isSameIpType(String me, String he) {
        boolean meIsV4 = isLegalIpV4(me);
        boolean meIsV6 = isLegalIpV6(me);
        boolean heIsV4 = isLegalIpV4(he);
        boolean heIsV6 = isLegalIpV6(he);
        boolean isAllIpv4 = meIsV4 && heIsV4;
        boolean isAllIpv6 = meIsV6 && heIsV6;
        return isAllIpv4 || isAllIpv6;
    }

    @ExternalInterface
    public static int compareIpV4(String ip1, String ip2) {
        return (int)compareIpV4(ip1, ip2, false);
    }

    public static long compareIpV4(String ip1, String ip2, boolean flag) {
        if(ip1 == null) {
            ip1 = "0.0.0.0";
        }

        if(ip2 == null) {
            ip2 = "0.0.0.0";
        }

        long ip1Long = convertIpV4ToLong(ip1);
        long ip2Long = convertIpV4ToLong(ip2);
        return flag?ip2Long - ip1Long:(ip1Long < ip2Long?-1L:(ip1Long > ip2Long?1L:0L));
    }

    @ExternalInterface
    public static int compareIpV6(String ip1, String ip2) {
        String ipa1 = null;
        String ipa2 = null;

        try {
            ipa1 = ((Inet6Address)Inet6Address.getByName(ip1)).getHostAddress();
            ipa2 = ((Inet6Address)Inet6Address.getByName(ip2)).getHostAddress();
        } catch (Exception var10) {
            LOG.error("Invalid ipV6 address");
            return 0;
        }

        ArrayList ip1Sections = new ArrayList();
        String[] ip2Sections = StringUtils.split(ipa1, ":");
        int fullIp1 = ip2Sections.length;

        int fullIp2;
        for(fullIp2 = 0; fullIp2 < fullIp1; ++fullIp2) {
            String i$ = ip2Sections[fullIp2];
            ip1Sections.add(i$.length() < 4?StringUtils.repeat("0", 4 - i$.length()) + i$:i$);
        }

        ArrayList var11 = new ArrayList();
        String[] var12 = StringUtils.split(ipa2, ":");
        fullIp2 = var12.length;

        for(int var15 = 0; var15 < fullIp2; ++var15) {
            String section = var12[var15];
            var11.add(section.length() < 4?StringUtils.repeat("0", 4 - section.length()) + section:section);
        }

        String var13 = StringUtils.join(ip1Sections.iterator(), ":");
        String var14 = StringUtils.join(var11.iterator(), ":");
        if(var13.compareTo(var14) == 0) {
            return 0;
        } else if(var13.compareTo(var14) > 0) {
            return 1;
        } else {
            return -1;
        }
    }

    @ExternalInterface
    public static int compareIp(String ip1, String ip2) {
        if(isLegalIpV4(ip1) && isLegalIpV4(ip2)) {
            return compareIpV4(ip1, ip2);
        } else if(isLegalIpV6(ip1) && isLegalIpV6(ip2)) {
            return compareIpV6(ip1, ip2);
        } else {
            throw new NumberFormatException(ip1 + " and " + ip2 + " are not same IP type.");
        }
    }

    public static long rangeBetweenIpV4(String startIp, String endIp) {
        return convertIpV4ToLong(endIp) - convertIpV4ToLong(startIp);
    }

    public static double rangeBetweenIpV6(String startIp, String endIp) {
        return convertIpV6ToDouble(endIp) - convertIpV6ToDouble(startIp);
    }

    @ExternalInterface
    public static boolean isLegalIpV6(String ipv6) {
        return isLegalIpV6Common(ipv6) || isLegalIPV6Compatible(ipv6);
    }

    @ExternalInterface
    public static boolean isLegalIpV6Common(String ip) {
        try {
            InetAddress e = Inet6Address.getByName(ip);
            if(e instanceof Inet6Address) {
                ((Inet6Address)e).getHostAddress();
                return true;
            } else {
                return false;
            }
        } catch (Exception var2) {
            if(LOG.isDebugEnabled()) {
                LOG.debug((Object)null, var2);
            }

            return false;
        }
    }

    @ExternalInterface
    public static boolean isLegalIpV6All(String ip) {
        return isLegalIpV6Common(ip) || isLegalIPV6Compatible(ip) || isLegalIPV6Prefix(ip);
    }

    @ExternalInterface
    public static boolean isLegalIPV6Compatible(String ip) {
        return !isLegalIpV6Common(ip)?false:(StringUtils.isBlank(ip)?false:StringUtils.countMatches(ip, ".") == 3);
    }

    @ExternalInterface
    public static boolean isLegalIPV6Prefix(String ip) {
        if(StringUtils.isBlank(ip)) {
            return false;
        } else if(StringUtils.countMatches(ip, "/") == 1 && !ip.endsWith("/")) {
            String[] ips = StringUtils.split(ip, "/");
            boolean prefixLength = false;

            int prefixLength1;
            try {
                if(ips[1].length() > 1 && ips[1].startsWith("0")) {
                    return false;
                }

                prefixLength1 = Integer.parseInt(ips[1]);
            } catch (Exception var4) {
                return false;
            }

            return isLegalIpV6Common(ips[0]) && prefixLength1 >= 0 && prefixLength1 <= 128;
        } else {
            return false;
        }
    }

    @ExternalInterface
    public static List<Long> getAllIpByHost(String hostName) {
        ArrayList ipList = new ArrayList();
        InetAddress[] addresses = null;

        try {
            addresses = InetAddress.getAllByName(hostName);
        } catch (UnknownHostException var7) {
            return ipList;
        }

        InetAddress[] arr$ = addresses;
        int len$ = addresses.length;

        for(int i$ = 0; i$ < len$; ++i$) {
            InetAddress address = arr$[i$];
            ipList.add(Long.valueOf(convertIpV4ToLong(address.getHostAddress())));
        }

        return ipList;
    }

    public static String getIpInUrl(String ip) {
        return isLegalIpV6(ip)?"[" + ip + "]":ip;
    }

    @ExternalInterface
    public static String[] ipAddressParseUtil(String ipAddress) {
        String[] result = new String[2];
        if(ipAddress.contains("*")) {
            result[0] = ipAddress.replace("*", "0");
            result[1] = ipAddress.replace("*", "255");
        } else {
            result[0] = ipAddress;
            result[1] = ipAddress;
        }

        return result;
    }

    @ExternalInterface
    public static String getDNSName(String ipAddress) {
        if(dnsHashmap.size() >= 2000) {
            dnsHashmap.clear();
        }

        Integer syncDNSName = Integer.valueOf(0);
        String dnsname = null;
        if(dnsHashmap.containsKey(ipAddress)) {
            dnsname = (String)dnsHashmap.get(ipAddress);
        }

        if(dnsname != null) {
            return dnsname;
        } else {
            try {
                if(System.getProperty("os.name").startsWith("Linux")) {
                    synchronized(syncDNSName) {
                        InetAddress addr = InetAddress.getByName(ipAddress);
                        dnsname = addr.getCanonicalHostName().trim();
                    }
                } else {
                    InetAddress uhe = InetAddress.getByName(ipAddress);
                    dnsname = uhe.getCanonicalHostName().trim();
                }

                if(!dnsname.equals(ipAddress)) {
                    dnsHashmap.put(ipAddress, dnsname);
                }
            } catch (UnknownHostException var7) {
                dnsname = ipAddress;
            }

            if(dnsname == null) {
                dnsname = ipAddress;
            }

            return dnsname;
        }
    }

    public static Map<String, String> getLocalhostAllIpAddresses() {
        try {
            LinkedHashMap se = new LinkedHashMap();
            Enumeration e = NetworkInterface.getNetworkInterfaces();

            while(e.hasMoreElements()) {
                NetworkInterface ni = (NetworkInterface)e.nextElement();
                String name = ni.getName();
                Enumeration ips = ni.getInetAddresses();
                if(ips.hasMoreElements()) {
                    InetAddress addr = (InetAddress)ips.nextElement();
                    if(!addr.isLoopbackAddress()) {
                        se.put(name, addr.getHostAddress());
                    }
                }
            }

            return se;
        } catch (SocketException var6) {
            LOG.error((Object)null, var6);
            return null;
        }
    }

    public static String getLocalhostFirstIpAddress() {
        Map map = getLocalhostAllIpAddresses();
        return map != null && map.size() > 0?(String)map.get(map.keySet().iterator().next()):null;
    }

    @ExternalInterface
    public static String convertIntToIpV4Mask(int length) {
        if(length >= 32) {
            return "255.255.255.255";
        } else if(length <= 0) {
            return "0.0.0.0";
        } else {
            String mask = StringUtils.repeat("1", length) + StringUtils.repeat("0", 32 - length);
            ArrayList list = new ArrayList();

            for(int i = 0; i < mask.length(); i += 8) {
                list.add(convertBinaryToDecimal(StringUtils.substring(mask, i, i + 8)));
            }

            return StringUtils.join(list.iterator(), ".");
        }
    }

    @ExternalInterface
    public static int convertIpV4MaskToInt(String v4Mask) {
        String[] segs = StringUtils.split(v4Mask, ".");
        String strV4 = "";
        String[] arr$ = segs;
        int len$ = segs.length;

        for(int i$ = 0; i$ < len$; ++i$) {
            String seg = arr$[i$];
            strV4 = strV4 + Integer.toBinaryString(Integer.valueOf(seg).intValue());
        }

        return StringUtils.countMatches(strV4, "1");
    }

    @ExternalInterface
    public static String convertIntToV6Mask(int length) {
        if(length >= 128) {
            return "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff";
        } else if(length <= 0) {
            return "0:0:0:0:0:0:0:0";
        } else {
            String mask = StringUtils.repeat("1", length) + StringUtils.repeat("0", 128 - length);
            ArrayList list = new ArrayList();

            for(int i = 0; i < mask.length(); i += 16) {
                list.add(convertBinaryToHex(StringUtils.substring(mask, i, i + 16)));
            }

            return StringUtils.join(list.iterator(), ":");
        }
    }

    public static String getIpv6Subnet(String ipv6, int maskLength) {
        String ipAddr = null;

        try {
            ipAddr = ((Inet6Address)Inet6Address.getByName(ipv6)).getHostAddress();
        } catch (Exception var8) {
            LOG.error("Invalid ipV6 address");
            return "";
        }

        ArrayList ipSections = new ArrayList();
        String[] maskSections = ipAddr.split(":");
        int subnetSections = maskSections.length;

        int i;
        for(i = 0; i < subnetSections; ++i) {
            String section = maskSections[i];
            ipSections.add(section.length() < 4?StringUtils.repeat("0", 4 - section.length()) + section:section);
        }

        maskSections = convertIntToV6Mask(maskLength).split(":");
        String[] var9 = new String[maskSections.length];

        for(i = 0; i < maskSections.length; ++i) {
            var9[i] = Integer.toHexString(Integer.valueOf((String)ipSections.get(i), 16).intValue() & Integer.valueOf(maskSections[i], 16).intValue());
        }

        return StringUtils.join(var9, ":");
    }

    private static String convertBinaryToDecimal(String binary) {
        long result = 0L;

        for(int j = 0; j < binary.length(); ++j) {
            String s = StringUtils.substring(binary, j, j + 1);
            if(Integer.valueOf(s).intValue() != 0) {
                result = (long)((double)result + Math.pow(2.0D, (double)(binary.length() - 1 - j)) * (double)Integer.valueOf(s).intValue());
            }
        }

        return String.valueOf(result);
    }

    private static String convertBinaryToHex(String binary) {
        int result = 0;

        for(int j = 0; j < binary.length(); ++j) {
            String s = StringUtils.substring(binary, j, j + 1);
            if(Integer.valueOf(s).intValue() != 0) {
                result = (int)((double)result + Math.pow(2.0D, (double)(binary.length() - 1 - j)) * (double)Integer.valueOf(s).intValue());
            }
        }

        return Integer.toHexString(result);
    }

    private static boolean isLegalIPV6(String ip, int section) {
        if(StringUtils.isBlank(ip)) {
            return false;
        } else if(StringUtils.countMatches(ip, "::") >= 2) {
            return false;
        } else if(StringUtils.countMatches(ip, ":::") > 0) {
            return false;
        } else if(ip.endsWith(":") && !ip.endsWith("::")) {
            return false;
        } else if(StringUtils.equals(ip, "::")) {
            return true;
        } else {
            Pattern p = Pattern.compile("[0-9a-fA-F]{1,4}");
            String[] list;
            String[] arr$;
            int i$;
            if(StringUtils.contains(ip, "::")) {
                list = StringUtils.splitByWholeSeparator(ip, "::");
                String[] var12;
                if(list.length == 2) {
                    arr$ = StringUtils.split(list[0], ":");
                    var12 = StringUtils.split(list[1], ":");
                    i$ = arr$.length + var12.length;
                    if(i$ >= section) {
                        return false;
                    }

                    ArrayList var14 = new ArrayList();
                    String[] var15 = arr$;
                    int s2 = arr$.length;

                    int i$1;
                    String s3;
                    for(i$1 = 0; i$1 < s2; ++i$1) {
                        s3 = var15[i$1];
                        var14.add(s3);
                    }

                    var15 = var12;
                    s2 = var12.length;

                    for(i$1 = 0; i$1 < s2; ++i$1) {
                        s3 = var15[i$1];
                        var14.add(s3);
                    }

                    Iterator var16 = var14.iterator();

                    while(var16.hasNext()) {
                        String var17 = (String)var16.next();
                        if(!p.matcher(var17).matches()) {
                            return false;
                        }
                    }
                } else {
                    arr$ = StringUtils.splitByWholeSeparator(StringUtils.remove(ip, "::"), ":");
                    if(arr$.length >= section || arr$.length == 0) {
                        return false;
                    }

                    var12 = arr$;
                    i$ = arr$.length;

                    for(int var13 = 0; var13 < i$; ++var13) {
                        String s1 = var12[var13];
                        if(!p.matcher(s1).matches()) {
                            return false;
                        }
                    }
                }
            } else {
                list = StringUtils.split(ip, ":");
                if(list.length != section) {
                    return false;
                }

                arr$ = list;
                int len$ = list.length;

                for(i$ = 0; i$ < len$; ++i$) {
                    String s = arr$[i$];
                    if(!p.matcher(s).matches()) {
                        return false;
                    }
                }
            }

            return true;
        }
    }

    public static int getClassOfIpAdress(String ip) {
        if(!isLegalIpV4(ip)) {
            throw new IllegalArgumentException("Illegal arguments : " + ip);
        } else {
            String sep = "\\x2e";
            String[] ipSegs = ip.split(sep);
            String ipSeg = ipSegs[0];
            int ipSegDigit = Integer.parseInt(ipSeg);
            String binStr = Integer.toBinaryString(ipSegDigit);
            String tmpStr = binStr;

            for(int binaryChars = 0; binaryChars < 8 - tmpStr.length(); ++binaryChars) {
                binStr = "0" + binStr;
            }

            char[] var8 = binStr.toCharArray();
            if(var8.length == 8) {
                if(48 == var8[0]) {
                    return 1;
                }

                if(49 == var8[0] && 48 == var8[1]) {
                    return 2;
                }

                if(49 == var8[0] && 49 == var8[1] && 48 == var8[2]) {
                    return 3;
                }

                if(49 == var8[0] && 49 == var8[1] && 49 == var8[2] && 48 == var8[3]) {
                    return 4;
                }

                if(49 == var8[0] && 49 == var8[1] && 49 == var8[2] && 49 == var8[3]) {
                    return 5;
                }
            }

            return 0;
        }
    }

    public static String getSubnetAddressForIpV4(String ip, String v4Mask) {
        if(isLegalIpV4(ip) && isLegalIpV4(v4Mask)) {
            String sep = "\\x2e";
            StringBuilder subNet = new StringBuilder();
            String[] ipSegs = ip.split(sep);
            String[] maskSegs = v4Mask.split(sep);

            for(int i = 0; i < ipSegs.length; ++i) {
                String ipSeg = ipSegs[i];
                String maskSeg = maskSegs[i];
                int ipSegDigit = Integer.parseInt(ipSeg);
                int maskSegDigit = Integer.parseInt(maskSeg);
                int andResult = ipSegDigit & maskSegDigit;
                subNet.append(String.valueOf(andResult));
                if(i != ipSegs.length - 1) {
                    subNet.append(".");
                }
            }

            return subNet.toString();
        } else {
            throw new IllegalArgumentException("Illegal arguments : " + ip + "," + v4Mask);
        }
    }

    public static String getFirstIpAddress(String subnetAddr) {
        if(!isLegalIpV4(subnetAddr)) {
            throw new IllegalArgumentException("Illegal arguments : " + subnetAddr);
        } else {
            long subnetAddrVal = convertIpV4ToLong(subnetAddr);
            String firstIp = convertLongToIpV4(subnetAddrVal + 1L);
            return firstIp;
        }
    }

    public static String getLastIpAddress(String subnetAddr, String v4Mask) {
        if(!isLegalIpV4(subnetAddr)) {
            throw new IllegalArgumentException("Illegal arguments : " + subnetAddr);
        } else {
            String broadcastAddr = getBroadcastAddress(subnetAddr, v4Mask);
            long broadcastAddrVal = convertIpV4ToLong(broadcastAddr);
            String lastIp = convertLongToIpV4(broadcastAddrVal - 1L);
            return lastIp;
        }
    }

    public static String getBroadcastAddress(String subnetAddr, String v4Mask) {
        if(isLegalIpV4(subnetAddr) && isLegalIpV4(v4Mask)) {
            int maskBits = convertIpV4MaskToInt(v4Mask);
            int hostBits = 32 - maskBits;
            StringBuilder subnetBinSb = new StringBuilder();
            String sep = "\\x2e";
            String[] ipSegs = subnetAddr.split(sep);

            String sunetBinStr;
            int broadcastIpSb;
            String broadcastBinStr;
            int length;
            int size;
            int i;
            for(int broadcastBinSb = 0; broadcastBinSb < ipSegs.length; ++broadcastBinSb) {
                sunetBinStr = ipSegs[broadcastBinSb];
                broadcastIpSb = Integer.parseInt(sunetBinStr);
                broadcastBinStr = Integer.toBinaryString(broadcastIpSb);
                length = broadcastBinStr.length();
                size = 8 - length;

                for(i = 1; i <= size; ++i) {
                    broadcastBinStr = "0" + broadcastBinStr;
                }

                subnetBinSb.append(broadcastBinStr);
            }

            StringBuilder var18 = new StringBuilder();
            sunetBinStr = subnetBinSb.toString();

            for(broadcastIpSb = 0; broadcastIpSb < sunetBinStr.length(); ++broadcastIpSb) {
                char var19 = sunetBinStr.charAt(broadcastIpSb);
                var18.append(var19);
                if(broadcastIpSb == maskBits - 1) {
                    break;
                }
            }

            for(broadcastIpSb = 1; broadcastIpSb <= hostBits; ++broadcastIpSb) {
                var18.append('1');
            }

            StringBuilder var20 = new StringBuilder();
            broadcastBinStr = var18.toString();
            length = broadcastBinStr.length();
            size = length / 8;

            for(i = 1; i <= size; ++i) {
                int start = (i - 1) * 8;
                int end = i * 8;
                String binary = broadcastBinStr.substring(start, end);
                String decimal = convertBinaryToDecimal(binary);
                var20.append(decimal);
                if(i != size) {
                    var20.append(".");
                }
            }

            return var20.toString();
        } else {
            throw new IllegalArgumentException("Illegal arguments : " + subnetAddr + "," + v4Mask);
        }
    }

    public static int getIpMaskBits(String mask) {
        if(!isLegalIpV4(mask)) {
            return Integer.valueOf(mask).intValue();
        } else {
            String[] segs = mask.split("\\x2e");
            String strV4 = "";
            String[] arr$ = segs;
            int len$ = segs.length;

            for(int i$ = 0; i$ < len$; ++i$) {
                String seg = arr$[i$];
                strV4 = strV4 + Integer.toBinaryString(Integer.valueOf(seg).intValue());
            }

            return StringUtils.countMatches(strV4, "1");
        }
    }

    public static void main(String[] args) {
        String testIp = "127.63.2.1";
        int type = getClassOfIpAdress(testIp);
        switch(type) {
        case 1:
            System.out.println("A : " + testIp);
            break;
        case 2:
            System.out.println("B : " + testIp);
            break;
        case 3:
            System.out.println("C : " + testIp);
            break;
        case 4:
            System.out.println("D : " + testIp);
            break;
        case 5:
            System.out.println("E : " + testIp);
            break;
        default:
            System.out.println("Illegal : " + testIp);
        }

        boolean ok = isLegalMask("255.192.0.0");
        System.out.println("Illegal : " + ok);
        String v4Mask = "10.255.0.0";
        System.out.println(convertIpV4MaskToInt(v4Mask));
    }
}
